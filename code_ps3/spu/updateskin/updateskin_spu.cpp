/***************************************************************************************************
*
*	DESCRIPTION		The entry point for the animation update system on SPUs.
*
*	NOTES
*
***************************************************************************************************/
#include "ntlib_spu/vecmath_spu_ps3.h"
#include "ntlib_spu/util_spu.h"
#include "ntlib_spu/debug_spu.h"
#include "ntlib_spu/fixups_spu.h"

#include "gfx/updateskin_ppu_spu.h"

#include "core/perfanalyzer_spu_ps3.h"



SPU_MODULE_FIXUP()

//
//	Entry point for the code on this SPU.
//


struct CSkinMatrix
{
public:
	CVector		m_obRow0;
	CVector		m_obRow1;
	CVector		m_obRow2;
};

struct Transform;

struct GpSkeleton 
{
public:

	enum
	{
		kOwnsMemory	= ( 1 << 0 ),
		kIsLocked	= ( 1 << 1 ),
	};

	static const int	kMaxJointDepth	= 64;

	uint32_t					m_flags;
	uint32_t					m_jointCount;

	const	void*				m_pSkeletonDef;			// Pointers to R/O data within GpSkeleton
	const	void*				m_pJointLinkage;
	const	void*				m_pJointBindPose;

	uint8_t*					m_pJointFlagsArray;		// Storage for joint flags

	void*						m_pJointArray;			// Storage for joint information (128 byte aligned start/size)
	CMatrix*					m_pWorldMatrix;			// Storage for world matrices (128 byte aligned start/size );

	void*						m_pDrivenKeys;			// Driven key information

	CMatrix						m_transform;			// Master position/orientation of skeleton
};

class CHierarchy: public GpSkeleton
{
public:
	CHierarchy *		m_pobParent;					// This is a pointer to the parent, or NULL.
	CHierarchy *		m_pobNextSibling;				// This is a pointer to the next sibling, or NULL.
	CHierarchy *		m_pobFirstChild;				// This is a pointer to the first child, or NULL. 
	int32_t				m_iFlags;						// Flags.. 

	int32_t				m_iTransformCount;				// Number of transforms/bones we have in this hierarchy. This does not include additionally added transforms. Only used to determine size of arrays.
	Transform *			m_pobTransformArray;			// Pointer to the root Transform in this hierarchy. Must not be NULL. ***ROOT TRANSFORM WILL ALWAYS BE INDEX 0***
	CSkinMatrix *		m_pobSkinMatrixArray;			// Pointer to array of final skinning matrices (4x3 transpose format) that are used by rendering (or NULL if not skinned)
	uint32_t			m_uiHierarchyKey;				// A 32-bit hash generated by the names of the transforms used to generate the hierarchy. This can be used
														// on non-character animations to stop playing them on incorrect hierarchies.

	uint32_t			m_uiLastRenderedTick;			// System tick when this hierarchy was last used in a rendering operation

	CPoint *			m_BoneOffsetArray;

	// We have some pointers to commonly used data inside the clump. I figure it's good for data locality..
	const CMatrix *		m_pobSkinToBoneArray;			// R/O pointer to skin->bone matrices in root data (or NULL if there are no skinned components). Must be in same order as transforms. Can be NULL.
	const int8_t *		m_pCharacterBoneToIndexArray;	// R/O pointer to character bone->index array.. (NULL for non-character objects).
	const void*			m_pobClumpHeader;				// R/O pointer to the CClumpHeader used to construct this hierarchy.

};

struct NonHierarchyTransformData
{
	CQuat	m_rotation;
	CPoint	m_translation;
	CVector	m_scale;
	CMatrix	m_obWorldMatrix;				
	int32_t	m_iFlags;
};

// Flags for the Transform object 
enum	TRANSFORM_FLAGS
{
	TRANSF_WORLD_MATRIX_INVALID		= ( 1 << 0 ),		// 0x00000001 : Is world matrix invalid?
									
	// I've left as much space (from 1<<1 to 1<<3) as I can as a guard against ATGs GpJoint
	// defining more flags - we MUST NEVER clash with their flags and we MUST ALWAYS
	// make sure that TRANSF_WORLD_MATRIX_INVALID is equal to GpJoint::kWorldMatrixInvalid;
	// this is asserted for at compile-time in Hierarchy.cpp. [ARV].

	TRANSF_WORLD_ROTATION_INVALID	= ( 1 << 4 ),		// 0x00000010 : Is world rotation invalid?
//	TRANSF_LOCAL_MATRIX_INVALID		= ( 1 << 5 ),		// 0x00000020 : Is the local matrix invalid? Remember it's now calculated and cached from the decompose joint representation.

	TRANSF_IS_WORLD_ROOT			= ( 1 << 6 ),		// 0x00000040 : Set for the transform that's used to define the world root
	TRANSF_IS_EXTERNAL				= ( 1 << 7 ),		// 0x00000080 : Set if the Transform was externally created
};

struct Transform
{
public:

	CMatrix	GetWorldMatrixFast(void) const;

public:
	CQuat						m_obWorldRotation;		// World rotation formed from m_obWorldMatrix. The value is cached as appropriate.

	NonHierarchyTransformData*	m_TransformData;
	Transform *					m_pobParent;			// Linkage and flags.
	Transform *					m_pobNextSibling;		
	Transform *					m_pobFirstChild;		

	CHierarchy *				m_pobParentHierarchy;	// Pointer to the parent hierarchy, or NULL
	void *						m_pobExternalData;		// A pointer to additional/external data. 

	int32_t						m_HierarchyIndex;		// Index in parent hierarchy's arrays (local matrix etc...).
};

static const int32_t InvalidIndex = -1;
/*
int32_t Transform::GetFlags() const
{
	ntError_p( m_HierarchyIndex == InvalidIndex || m_pobParentHierarchy != NULL, ("If we have a valid hierarchy index then we must have a hierarchy to index into.") );
	return m_HierarchyIndex == InvalidIndex ? m_TransformData->m_iFlags : m_pobParentHierarchy->m_pJointFlagsArray[ m_HierarchyIndex ];
}
 */

uint8_t g_JointsFlag[1024];

#define MAX_MATRIX_COUNT	(200)
#define TRANSFORM_SIZE		(160)

#define IN_SKIN_TO_BONE_BUFFER_SIZE		(MAX_MATRIX_COUNT * sizeof(CMatrix))
#define IN_TRANSFORM_BUFFER_SIZE		(MAX_MATRIX_COUNT * TRANSFORM_SIZE)
#define OUT_BUFFER_SIZE					(MAX_MATRIX_COUNT * sizeof(CSkinMatrix))


void AlignDMASizePointerAndSize( void* in_pointer, uint32_t in_size, uint32_t &out_pointer, uint32_t &out_size )
{
	out_pointer = ((uint32_t)in_pointer) & ~0xF;
	out_size = in_size + ( (uint32_t)in_pointer - out_pointer );
	out_size = (out_size + 0xF) & ~0xF;
}

ntDMA::Params dmaParams2;
const Transform* THIS;
NonHierarchyTransformData* TRANSFORMDATA;
CHierarchy* HIERARCHY;
CMatrix* MATRIX;

NonHierarchyTransformData NHTdata;
CHierarchy Hierarchydata;
CMatrix matrix;

CMatrix Transform::GetWorldMatrixFast(void) const
{
	ntError_p( m_HierarchyIndex == InvalidIndex || m_pobParentHierarchy != NULL, ("If we have a valid hierarchy index then we must have a hierarchy to index into.") );

	THIS = this;

	ntDMA_ID data_ID;
	data_ID = ntDMA::GetFreshID();	

	if ( m_HierarchyIndex == InvalidIndex )
	{
		// just allocate a few bytes on the stack

		dmaParams2.Init32( (void*)(&NHTdata), (uint32_t)m_TransformData, sizeof( NonHierarchyTransformData ), data_ID );
		ntDMA::DmaToSPU( dmaParams2 );
		ntDMA::StallForCompletion( data_ID );

		TRANSFORMDATA = &NHTdata;
		
		ntAssert(!( NHTdata.m_iFlags & TRANSF_WORLD_MATRIX_INVALID ));

		ntDMA::FreeID( data_ID );
		return ( NHTdata.m_obWorldMatrix );
	}
	else
	{
		// just allocate a few bytes on the stack
		dmaParams2.Init32( (void*)(&Hierarchydata), (uint32_t)m_pobParentHierarchy, sizeof( CHierarchy ), data_ID );
		ntDMA::DmaToSPU( dmaParams2 );
		ntDMA::StallForCompletion( data_ID );

		HIERARCHY = &Hierarchydata;

#ifndef _RELEASE
		uint32_t JointIndices, JointIndicesSize;
		AlignDMASizePointerAndSize( Hierarchydata.m_pJointFlagsArray, Hierarchydata.m_jointCount, JointIndices, JointIndicesSize);
		dmaParams2.Init32( (void*)(g_JointsFlag), (uint32_t)JointIndices, JointIndicesSize, data_ID );
		ntDMA::DmaToSPU( dmaParams2 );
		ntDMA::StallForCompletion( data_ID );

		uint8_t* indices = g_JointsFlag + (  (uint32_t)Hierarchydata.m_pJointFlagsArray  - JointIndices );

		ntAssert(!( indices[ m_HierarchyIndex ] & TRANSF_WORLD_MATRIX_INVALID ));
#endif
		ntError_p( m_HierarchyIndex >= 0 || m_HierarchyIndex < Hierarchydata.m_iTransformCount, ("Invalid transform index. Out of bounds.") );

		dmaParams2.Init32( (void*)&matrix, (uint32_t)(Hierarchydata.m_pWorldMatrix + m_HierarchyIndex), sizeof(matrix), data_ID );
		ntDMA::DmaToSPU( dmaParams2 );
		ntDMA::StallForCompletion( data_ID );

		MATRIX = &matrix;

		ntDMA::FreeID( data_ID );
		return matrix;
	}
};


ntDMA::Params dmaParams;
ntDMA::Params dmaInA, dmaInB;	

CMatrix* pSkinToBoneArray;
Transform* pTransformArray;
CMatrix* pNextSkinToBoneArray;
Transform* pNextTransformArray;
void *pSkinToBoneArrayMemory;
void *pTransformArrayMemory;
void *pSkinMatrixArrayMemory;
CMatrix obSkinToRoot;
CMatrix	obMatrix;
CSkinMatrix* pSkinMatrixArray;
SpuUpdateSkin::HierarchyData* DATA;

extern "C" void SpuMain( SPUArgumentList &params )
{
	//ntBreakpoint();

	INSERT_PA_BOOKMARK ( PABM_SPU_UPDATESKIN);

	// Allocate some mem
	pSkinToBoneArrayMemory =  Allocate( IN_SKIN_TO_BONE_BUFFER_SIZE * 2 );
	pTransformArrayMemory  =  Allocate( IN_TRANSFORM_BUFFER_SIZE * 2 );
	pSkinMatrixArrayMemory =  Allocate( OUT_BUFFER_SIZE * 2 );

	ntAssert( pSkinToBoneArrayMemory != NULL );
	ntAssert( pTransformArrayMemory != NULL );
	ntAssert( pSkinMatrixArrayMemory != NULL );

	// Get Transform count
	GetU32Input( i32HierarchyCount, 0 );
	uint16_t i16HierarchyCount = (uint16_t)(i32HierarchyCount & 0xFFFF);
	// Get Hierachies data
	GetArrayInput( SpuUpdateSkin::HierarchyData*, pHierarchies, 1 );

	// Initialize Buffer 
	uint16_t BufferToggle = 0;

	ntDMA_ID in_SkinToBoneArray_ID[2];
	in_SkinToBoneArray_ID[0] = ntDMA::GetFreshID();
	in_SkinToBoneArray_ID[1] = ntDMA::GetFreshID();

	ntDMA_ID in_TransformArray_ID[2];
	in_TransformArray_ID[0] = ntDMA::GetFreshID();
	in_TransformArray_ID[1] = ntDMA::GetFreshID();

	ntDMA_ID out_SkinMatrixArray_ID[2];
	out_SkinMatrixArray_ID[0] = ntDMA::GetFreshID();
	out_SkinMatrixArray_ID[1] = ntDMA::GetFreshID();


	dmaParams.Init32( pSkinToBoneArrayMemory, (uint32_t)(pHierarchies[0].m_pSkinToBoneArray), 
					  sizeof(CMatrix) * pHierarchies[0].m_ui32TransformCount,  in_SkinToBoneArray_ID[BufferToggle] );
	// transfer skin to bone array from XDR mem to our local store
	ntDMA::DmaToSPU( dmaParams );

	dmaParams.Init32( pTransformArrayMemory, (uint32_t)(pHierarchies[0].m_pTransformArray), 
					  TRANSFORM_SIZE * pHierarchies[0].m_ui32TransformCount,  in_TransformArray_ID[BufferToggle] );
	// transfer transform array from XDR mem to our local store
	ntDMA::DmaToSPU( dmaParams );


	// loop through each hierarchy
	for( uint16_t i=0; i < i16HierarchyCount; i++)
	{

		DATA = &pHierarchies[i];

		pSkinToBoneArray = (CMatrix*)((char*)pSkinToBoneArrayMemory + BufferToggle * IN_SKIN_TO_BONE_BUFFER_SIZE);
		pTransformArray = (Transform*)((char*)pTransformArrayMemory + BufferToggle * IN_TRANSFORM_BUFFER_SIZE);
		pNextSkinToBoneArray = (CMatrix*)((char*)pSkinToBoneArrayMemory + (BufferToggle^1) * IN_SKIN_TO_BONE_BUFFER_SIZE);
		pNextTransformArray = (Transform*)((char*)pTransformArrayMemory + (BufferToggle^1) * IN_TRANSFORM_BUFFER_SIZE);
		

		uint16_t next = i + 1;
		if ( next < i16HierarchyCount )
		{
			dmaInA.Init32( pNextSkinToBoneArray, (uint32_t)(pHierarchies[next].m_pSkinToBoneArray),
				           sizeof(CMatrix) * pHierarchies[next].m_ui32TransformCount, in_SkinToBoneArray_ID[BufferToggle^1] );

			dmaInB.Init32( pNextTransformArray, (uint32_t)(pHierarchies[next].m_pTransformArray),
				           TRANSFORM_SIZE * pHierarchies[next].m_ui32TransformCount, in_TransformArray_ID[BufferToggle^1] );

		}

		// stall for prefetched data
		ntDMA::StallForCompletion( in_SkinToBoneArray_ID[ BufferToggle ] );
		ntDMA::StallForCompletion( in_TransformArray_ID[ BufferToggle ] );

		// Prefetch Data
		if ( next < i16HierarchyCount )
		{
			ntDMA::DmaToSPU( dmaInA );	
			ntDMA::DmaToSPU( dmaInB );	
		}
		
		// let's compute some stuff!
		obSkinToRoot = pTransformArray[0].GetWorldMatrixFast().GetAffineInverse();
		//CMatrix	obMatrix;

		pSkinMatrixArray = (CSkinMatrix*)((char*)pSkinMatrixArrayMemory + BufferToggle * OUT_BUFFER_SIZE);
		ntDMA::StallForCompletion( out_SkinMatrixArray_ID[ BufferToggle ] );

		for( uint16_t j = 0; j < pHierarchies[i].m_ui32TransformCount; j++)
		{
			obMatrix = pSkinToBoneArray[ j ] * pTransformArray[ j ].GetWorldMatrixFast() * obSkinToRoot;
			obMatrix = obMatrix.GetTranspose();
			
			pSkinMatrixArray[j].m_obRow0.Quadword() = obMatrix.GetRow0();
			pSkinMatrixArray[j].m_obRow1.Quadword() = obMatrix.GetRow1();
			pSkinMatrixArray[j].m_obRow2.Quadword() = obMatrix.GetRow2();
		}
		
		dmaParams.Init32( pSkinMatrixArray, (uint32_t)(pHierarchies[i].m_pSkinMatrixArray), 
						  sizeof(CSkinMatrix) * pHierarchies[i].m_ui32TransformCount,  out_SkinMatrixArray_ID[BufferToggle] );
		// transfer transform array from XDR mem to our local store
		ntDMA::DmaToPPU( dmaParams );	

		BufferToggle = BufferToggle^1;
	}
	ntDMA::StallForCompletion( in_SkinToBoneArray_ID[0] );
	ntDMA::StallForCompletion( in_SkinToBoneArray_ID[1] );
	ntDMA::StallForCompletion( in_TransformArray_ID[0] );
	ntDMA::StallForCompletion( in_TransformArray_ID[1] );
	ntDMA::StallForCompletion( out_SkinMatrixArray_ID[0] );
	ntDMA::StallForCompletion( out_SkinMatrixArray_ID[1] );

	ntDMA::FreeID( in_SkinToBoneArray_ID[0] );
	ntDMA::FreeID( in_SkinToBoneArray_ID[1] );
	ntDMA::FreeID( in_TransformArray_ID[0] );
	ntDMA::FreeID( in_TransformArray_ID[1] );
	ntDMA::FreeID( out_SkinMatrixArray_ID[0] );
	ntDMA::FreeID( out_SkinMatrixArray_ID[1] );
}
