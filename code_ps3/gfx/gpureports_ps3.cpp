//--------------------------------------------------
//!
//!	\file GPUReport_ps3.cpp
//!
//--------------------------------------------------

#include "gfx/gpureports_ps3.h"

#ifdef PLATFORM_PS3
#include <Gc/GcKernel.h>
#endif
//--------------------------------------------------
//!
//!	GPUReport
//! constructor
//!
//--------------------------------------------------
GPUReport::GPUReport(	uint32_t uiMaxPerViewReports, uint32_t uiMaxViews, uint32_t uiGameHz ) :
						m_uiMaxPerViewReports( uiMaxPerViewReports ),
						m_uiMaxViews( uiMaxViews ),
						m_uiGameHz( uiGameHz ),
						m_bReportsEnabled( false )
{
	// compute how much memory we need to store the GPU reports
	m_uiRequiredMem = (((s_uiReservStamps + ( m_uiMaxPerViewReports * m_uiMaxViews * 2 )) * sizeof( Ice::Render::Report )) & ~0x7f) + 0x80;

	// allocate some IO addressable mem that will be used to store GPU reports
//	m_pIOStampsMemory = (Ice::Render::Report*)NT_MEMALIGN_CHUNK( Mem::MC_RSX_MAIN_INTERNAL, m_uiRequiredMem, 4 );
	uint32_t uiReportsMem;
	GcKernel::GetReportBufferMemoryInfo( (void**)&m_pIOStampsMemory, &uiReportsMem );
	memset ( m_pIOStampsMemory, 0x0, m_uiRequiredMem );

	ntAssert_p( uiReportsMem >= m_uiRequiredMem, ("There's not enough GPU Reports memory! try again lowering the number of viewports.. "));

	// we need save somwhere our GPU reports
	m_pStampsMemory = (Ice::Render::Report*)NT_MEMALIGN_CHUNK( Mem::MC_GFX, m_uiRequiredMem, 4 );
	memset ( m_pStampsMemory, 0x0, m_uiRequiredMem );
}


//--------------------------------------------------
//!
//!	GPUReport
//! destructor
//!
//--------------------------------------------------
GPUReport::~GPUReport()
{
//	NT_FREE_CHUNK(Mem::MC_RSX_MAIN_INTERNAL, (uintptr_t)m_pIOStampsMemory);
	NT_FREE_CHUNK(Mem::MC_GFX, (uintptr_t)m_pStampsMemory);
}

//--------------------------------------------------
//!
//!	GPUReport::StartReports()
//! Opens a GPU reports session
//!
//--------------------------------------------------

bool GPUReport::StartReports(void)
{
	ntAssert_p( m_bReportsEnabled == false, ("You can't start GPU reports if you did not close the previous reports session! call CloseReports()"));

	if ( !m_bReportsEnabled )
	{
		// enable reports
		m_bReportsEnabled = true;
		// clear all reports
		memset( (void*)&m_pIOStampsMemory[ s_uiEOFReportID ], 0x0, m_uiRequiredMem );
		return true;
	}
	return false;
}

//--------------------------------------------------
//!
//!	GPUReport::CloseReports()
//! Closes a GPU reports session
//!
//--------------------------------------------------

bool GPUReport::CloseReports(void)
{
	ntAssert_p( m_bReportsEnabled == true, ("You can't stop GPU reports if you have not previously started a reports session! call StartReports()"));

	if ( m_bReportsEnabled )
	{
		// enable reports
		m_bReportsEnabled = false;
		return true;
	}
	return false;
}

//--------------------------------------------------
//!
//!	GPUReport::CloseReports()
//! Collect all GPU Reports generated by last session
//!
//--------------------------------------------------

bool GPUReport::CollectReports(void)
{
	ntAssert_p( m_bReportsEnabled == false, ("You can't start GPU reports if you did not close the previous reports session! call CloseReports()"));

	if ( !m_bReportsEnabled )
	{
		// save reports
		memcpy( m_pStampsMemory, m_pIOStampsMemory, m_uiRequiredMem ); 
		return true;
	}
	return false;
}


//--------------------------------------------------
//!
//!	GPUReport::StartReport()
//! Start a new GPU report
//!
//--------------------------------------------------

bool GPUReport::StartReport( GPUR_ID eReportID, uint32_t uiViewID )
{
	ntAssert_p( m_bReportsEnabled == true, ("Can't start a new report if you don't open a new GPU reports session! call StartReports()"));

	if ( m_bReportsEnabled )
	{
		// compute report index
		uint32_t uiReportIndex = s_uiReservStamps + (m_uiMaxPerViewReports * uiViewID) + ( eReportID<<1 );
		// add a report
		AddReport( Ice::Render::kReportPixelCount, uiReportIndex );
		return true;
	}
	return false;
}

//--------------------------------------------------
//!
//!	GPUReport::CloseReport()
//! Close a GPU report
//!
//--------------------------------------------------


bool GPUReport::CloseReport( GPUR_ID eReportID, uint32_t uiViewID )
{
	ntAssert_p( m_bReportsEnabled == true, ("Can't close a new report if you haven't opened a new GPU reports session! call StartReports() and StartReport()"));

	if ( m_bReportsEnabled )
	{
		// compute report index
		uint32_t uiReportIndex = s_uiReservStamps + (m_uiMaxPerViewReports * uiViewID) + ( eReportID<<1 ) + 1;
		// add a report
		AddReport( Ice::Render::kReportPixelCount, uiReportIndex );
		return true;
	}
	return false;
}

float GPUReport::GetReportFrameRelativeTime( GPUR_ID eReportID, uint32_t uiViewID  )
{
	// init time stamp
	U64 ui64TimeStamp = 0;
	
	uint32_t uiStartView = uiViewID;
	uint32_t uiEndView = uiViewID + 1;

	// if no particular viewport has been specified collect info on all the viewports
	if ( uiViewID == 0xffffffff ) 
	{
		uiStartView = 0;
		uiEndView = m_uiMaxViews;
	}

	// collect time stamps
	for ( uint32_t i = uiStartView; i < uiEndView; i++ )
	{
		// compute report index
		uint32_t uiReportIndex = s_uiReservStamps + (m_uiMaxPerViewReports * i) + ( eReportID<<1 );
		// add delta time
		ui64TimeStamp = ui64TimeStamp + m_pStampsMemory[ uiReportIndex + 1 ].m_timeStamp - m_pStampsMemory[ uiReportIndex ].m_timeStamp;
	}

//	float time = TicksToNanoSecs( ui64TimeStamp );
	return (100.0f * float(ui64TimeStamp) * (float)m_uiGameHz ) / ( 1000000000.0f );
}
