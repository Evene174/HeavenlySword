/*
 * Copyright (c) 2003-2005 Naughty Dog, Inc.
 * A Wholly Owned Subsidiary of Sony Computer Entertainment, Inc.
 * Use and distribution without consent strictly prohibited
 */

#ifndef ICE_ICEJOINTANIM_H
#define ICE_ICEJOINTANIM_H

#include "icebase.h"
#include "iceanimstructs.h"
#include "iceanimtaskman.h"
#include "icememorybuffer.h"

#if ICE_TARGET_PS3_PPU
# define ICEANIM_PERFORMANCE_STATS 1
#else
# define ICEANIM_PERFORMANCE_STATS 0
#endif

namespace Ice
{
	namespace BatchJob
	{
		// forward declarations for plug-ins
		class WorkBuffer;
		class CommandStream;
	}

	namespace Anim
    {
		// ----------------------------------------------------------------------------------------------------

		// NOTE: data structures and definitions that are shared with the SPU have now been
		// moved to iceanimstructs.h ...

		// ----------------------------------------------------------------------------------------------------

        /*!
         * This is the actual clip data.  It contains all global data for this clip that might be
		 * interesting to the general user.
		 * With iceanimclippriv.h, this header contains enough data to navigate the internal structure
		 * of a clip.
         */
        struct ClipData {
			U32           m_magic;				//!< Magic value incremented at each data version since 1.03 - one of kClipDataMagic*
			U32           m_hierarchyId;		//!< unique id of associated hierarchy
			U16           m_clipFlags;          //!< Union of ClipFlags
			U16           m_numTotalFrames;		//!< Total number of frames in animation.
			U16           m_numGroups;          //!< Number of animation groups.
			U16           m_numBlocks;          //!< Number of blocks total (== m_numGroups unless (m_clipFlags & kClipKeysUnshared))

			U32			  m_rootAnimOffset;		//!< offset to root animation data
			U32			  m_formatDataOffset;	//!< offset to format data dependant on m_clipFlags (one of AnimClip(*)FormatData)
			U32			  m_groupHeadersOffset;	//!< offset to AnimClipGroupHeaders array
			U32           m_blockHeadersOffset; //!< offset to AnimClip(*)BlockHeader array

			float         m_framesPerSecond;    //!< Sampling frame rate for time based playback.
			float		  m_secondsPerFrame;	//!< Inverse frame rate, for easy access.
			float         m_phasePerFrame;		//!< Inverse of (m_numTotalFrames-1), for easy access.
			U16           m_numJoints;			//!< From associated JointHierarchy::m_numAnimatedJoints
			U16           m_numFloatChannels;	//!< From associated JointHierarchy::m_numFloatChannels
			//---
			//[AnimClip(*)RootAnimData]			m_rootAnimData;					// Root animation data if (m_clipFlags & kClipLinearRootAnim)
			//[AnimClip(*)FormatData]			m_animFormatData;				// Format specific data (ex. key frame table for shared keys)
            //AnimClipGroupHeader				m_groupHeaders[m_numGroups];	// Headers for group constant data, with offsets to associated AnimClipGroupConstData and AnimClip(*)BlockHeader.
            //AnimClip(*)BlockHeader 			m_blockHeaders[m_numBlocks];	// Headers for compressed keyframe data blocks, with offsets to associated m_blockData entries.
			//AnimClipUnsharedKeysBlockLayoutData m_blockLayoutData[];			// Table of block data offsets per block per key copy command, if

			//AnimClipGroupConstData 			m_clipConstData[m_numGroups];	// Variable sized data describing each clip group.
			//<various formats>					m_blockData[m_numBlocks];		// Variable sized data blocks containing time dependent animation information.
        };

		enum ClipFlags {
			kClipLooping = 					0x0001,		//!< Clip is looping (last frame duplicates first)
			kClipAdditive = 				0x0002,		//!< Clip is additive (was generated by subtracting a base pose or animation)
			kClipLinearRootAnim =			0x0004,		//!< Clip has AnimClipLinearRootAnimData
			kClipKeysShared =				0x0010,		//!< Clip is compressed using one set of non-uniform key times shared by all joint parameters of the animation.
			kClipKeysUnshared =				0x0020,		//!< Clip is compressed using separate non-uniform key times for each scale, rotation, and translation joint parameter.
		};

		/*!
		 * When it is useful to extract part of the animation of the root node as a track to apply to the object matrix,
		 * we store the data in a AnimClip(*)RootAnimData struct.
		 * Currently, as this track must be evaluated on the PPU, we only support linear animations, effectively with one
		 * identity key frame at frame 0, and the following keyframe at frame clipData->m_numTotalFrames-1:
		 */
		struct AnimClipLinearRootAnimData {
			SMath::Vector	m_scaleLinearOffset;
			SMath::Quat		m_quatLinearOffset;
			SMath::Vector	m_transLinearOffset;
		};

		// ===================================================================================================================

		/*!
		 * The JointHierarchy is a major structure for all animation-related data pertaining
		 * to a specific model. It contains parenting data, but also set-driven key information,
		 * as well as constraint data.
		 * Its internal structure may be parsed with icejointhierarchypriv.h.
		 */
        struct JointHierarchy {
            U32           m_magic;                      //!< Magic word to identify structure version.
			U32           m_hierarchyId;				//!< Unique id assigned to this hierarchy.
			U32           m_totalSize;                  //!< Total size in bytes for this hierarchy.
            U16           m_numTotalJoints;             //!< Total number of joints in hierarchy.
			U16           m_numFloatChannels;			//!< Number of animateable float channels.

			U8            m_numSets;                    //!< Number of joint sets (max 2, currently).
			U8            pad;
			U16           m_numScalars;                 //!< Required number of scalar table entries to process SdkData.
			U16           m_numSdkConstants;            //!< Number of sdk constants
			U16           m_numInputControls;			//!< Number of external input float controls.
			U16           m_numOutputControls;          //!< Number of external output float controls.
			U16           m_numInternalFloatChannels;	//!< Number of float channels that are consumed internally by sdks or constraints (which are always sorted to the front of the float channels)
			U8            m_numSdkCommands;             //!< Number of SDK command headers.
			U8            m_numConstraintCommands;      //!< Number of constraint command headers.
			U8            m_numChannelGroups;			//!< Number of blend processing groups == num joint groups + num float channel groups.
														//!< Sets the number of ValidBits required to hold a pose and the number of
														//!< JointFactors groups required for a blend operation.
			U8            m_numSdkToConstraintVecs;     //!< Number of extra qwords output at end of JointParam table for vector constraint inputs.

			U32           m_defaultPoseOffset;          //!< Offset from header to default pose for primary joint set (local SQTs to generate the bind pose).
			U32           m_secondaryDefaultPoseOffset; //!< Offset from header to packed default pose data for secondary joint set (local SQTs to generate the bind pose).
			U32           m_defaultFloatChannelsOffset;	//!< Offset to default values for float channels; float[m_numFloatChannels]
			U32           m_defaultInputControlsOffset; //!< Offset to default external input float control values; float[m_numInputControls]

			U32           m_sdkCommandHeaderOffset;  	//!< Offset from header to SDK data command headers; SdkCommandHeader[m_numSdkCommands]
			U32           m_constraintCommandHeaderOffset; //!< Offset from header to constraint command headers; ConstraintCommandHeader[m_numConstraintCommands]
			U32           m_inverseBindPoseOffset;      //!< Offset from header to inverse bind pose matrices; Mat4x3[m_numTotalJoints]
			U32           m_debugParentInfoOffset;		//!< (DEBUG) Offset from header to DebugJointParentInfo[m_numTotalJoints].  0 if no debug info.

			U32           m_jointIdTableOffset;			//!< Offset to ids for output controls; U32[m_numTotalJoints]
			U32           m_floatChannelIdTableOffset;	//!< Offset to ids for output controls; U32[m_numFloatChannels]
			U32           m_inputControlIdTableOffset;	//!< Offset to ids for input controls; U32[m_numInputControls]
			U32           m_outputControlIdTableOffset;	//!< Offset to ids for output controls; U32[m_numOutputControls]

			U16           m_numAnimatedJoints;          //!< Number of joints driven by keyframe animation data (as opposed to SDK or constraint driven procedural joints)
			U16           m_numPrimaryJoints;           //!< Number of joints in first parenting (primary) set
			U16           m_numParentingQuads[2];       //!< Number of parenting quads in (primary) set 0 and (secondary) set 1.
			U32           m_parentingDataOffset[2];     //!< Offset from header to the joint parenting data for (primary) set 0 and (secondary) set 1.
			// Following is data.
		};

		/*!
		 * This is debug data describing the joint hierarchy's tree structure,
		 * stored as an array of m_numTotalJoints elements at
		 * ((U8*)hierarchy + hierarchy->m_parentInfoOffset)
		 *
		 * It is unused by the animation and rendering code (superceded by
		 * the data at hierarchy->m_parentingDataOffset[]), but has an easier
		 * to parse format for debugging purposes.
		 */
		struct DebugJointParentInfo
		{
			U32			m_flags;	//!< inheritScale flag in 0x1, secondary joint flag in 0x2
			U32			m_parent;	//!< Joint index of my parent, if none then this is the same as this joint.
			U32			m_child;	//!< Joint index of my first child, if none then this is the same as this joint.
			U32			m_sibling;	//!< Joint index of my next sibling, if last then this is the same as this joint.
		};

		// ===================================================================================================================

        ///
        /// All nodes in the blend group phase inherit from the AnimationNode.
		/// The first field of an animation node must be a node type.
		/// These nodes are used as driving data for the animation system during the
		/// animation phase, describing the "state" for the current frame.
        ///
		struct AnimationNode {
            U16		m_nodeType;		//!< What NodeType it is.
			U16		m_reserved;		//!< Reserved for use by animation system
        };

		/// A unique identifier for a AnimationNode.
		enum NodeType {
			kClipNode,				//!< Clip node (play an animation clip)
			kBlendNode,				//!< Blend node (blend animations)
			kPoseNode,				//!< Pose node (put object in a specific pose)
			kSnapshotNode,			//!< Snapshot node (snapshot the animation stack)
			kFlipNode,				//!< Flip node (flip part of animation)
			kUnaryPlugInNode,		//!< Unary PlugIn node (run custom code to generate or modify a pose)
			kBinaryPlugInNode,		//!< Binary PlugIn node (run custom code to combine two poses)
		};

		/*!
		 * Values stored in AnimationNode::m_reserved used by PreprocessAnimationNodes() to pass info to AnimateJoints*()
		 */
		enum AnimationNodeReserved
		{
			kNodeBreadthMask =		0x00FF,		// Node breadth
			kNodeRightBalanced =	0x8000,		// Node breadth is higher to right - we should process right tree in place rather than left tree
		};

		/// While evaluating animation nodes during the blending phase, joints and float channels
		/// are handled in blend groups that each contain 0 to kJointGroupSize joints and
		/// 0 to kFloatChannelGroupSize float channels.  Each set of joints and each set of float
		/// channels is a channel group and is associated with a ValidBits structure detailing
		/// which individual channels in that set have valid data defined.  A blend group may
		/// therefore contain one or two channel groups, depending on whether there are joints
		/// or float channels or both in the blend group.  If both, the first channel group is
		/// always associated with the joints, and the second with the float channels.
		///
		/// A BlendGroupDesc contains a description of the data being processed in one blend group.
		struct BlendGroupDesc {
			U32F m_group;				//!< index of this blend group
			U32F m_firstJoint;			//!< index of first joint in this blend group (0 .. pHierarchy->m_numAnimatedJoints-1-m_numJoints)
			U32F m_numJoints;			//!< number of joints in this blend group (0 .. kJointGroupSize)
			U32F m_firstFloatChannel;	//!< index of first float channel in this blend group (0 .. pHierarchy->m_numFloatChannels-1-m_numFloatChannels)
			U32F m_numFloatChannels;	//!< number of float channels in this blend group (0 .. kFloatChannelGroupSize)
			U32F m_firstChannelGroup;	//!< index of first channel group/ValidBits associated with this blend group (0 .. pHierarchy->m_numChannelGroups-1-m_numChannelGroups)
			U32F m_numChannelGroups;	//!< number of channel groups/ValidBits associated with this blend group (== (m_numJoints!=0) + (m_numFloatChannels!=0))
		};

		//----------------------------------------------------------------------------------------

		/*!
         * A ClipNode simply refers to a clip in memory, and which keyframes to
		 * blend.
         *
         * The m_fTime field should continuosly be updated by the game code.
         */
        struct ClipNode : public AnimationNode {
			float			  m_fSample;			//!< index of sample to look up in clip, including fractional part
			ClipData const	 *m_clipData;			//!< clip to play
			ValidBits const	 *m_validMask;			//!< numJointGroups bitfields modifying (by bitwise and) which joints clipData will affect.
													//!< NULL is equivalent to all bits set, allowing the clip to play on every joint for which it has data.
        };

		//----------------------------------------------------------------------------------------

		/*!
		 * A pose node sends a pose to the animation task -
		 *  A pose contains the local space position of all joints in JointParams (SQT) format,
		 *  the values of all float channels, and bitfields defining which are valid.
		 *  Note that m_numChannelGroups == ((m_numTotalJoints + kJointGroupSize-1)/kJointGroupSize) + ((m_numFloatChannels + kFloatChannelGroupSize-1)/kFloatChannelGroupSize);
		 */
		struct PoseNode : public AnimationNode {
			ValidBits const		 *m_validBits;		//!< Pointer to the array of ValidBits[ JointHierarchy::m_numChannelGroups ]
			JointParams const	 *m_jointParams;	//!< Pointer to SQT array: JointParams[ JointHierarchy::m_numAnimatedJoints ]; may be NULL if JointHierarchy::m_numTotalJoints == 0
			float const          *m_floatChannels;	//!< Pointer to float array: float[ JointHierarchy::m_numFloatChannels ]; may be NULL if JointHierarchy::m_numFloatChannels == 0
		};

		//----------------------------------------------------------------------------------------

		/*!
		 * A snapshot node indicates that we want to take a snapshot of the tree at the node's
		 * position, saving a pose into 'm_jointParams' and 'm_floatChannels' and the specification
		 * of which joints and float channels have valid data into 'm_validBits'.
		 * Can be used again as a PoseNode.
		 */
		struct SnapshotNode : public AnimationNode
		{
			ValidBits		 *m_validBits;		//!< Pointer to space to return JointHierarchy::m_numChannelGroups ValidBits structs
			JointParams		 *m_jointParams;	//!< Pointer to space to return JointHierarchy::m_numAnimatedJoints JointParams (SQT); may be NULL if JointHierarchy::m_numTotalJoints == 0
			float			 *m_floatChannels;	//!< Pointer to space to return JointHierarchy::m_numFloatChannels float values; may be NULL if JointHierarchy::m_numFloatChannels == 0
			AnimationNode	 *m_subTree;		//!< Pointer to animation nodes to calculate the snapshot from.
		};

		//----------------------------------------------------------------------------------------

		/*!
		 * A blend node indicates that we want to blend the 'left' tree's result with
		 * the 'right' tree's result, using the specified blend operation BlendMode and
		 * blend factor.  Optionally, we can specify override blendfactors for some joints
		 * with a JointFactors array.
		 */
        struct BlendNode : public AnimationNode {
            AnimationNode			 *m_left;					//!< Pointer to the nodes to be blended.
            AnimationNode			 *m_right;					//!< Ditto.
            U32						  m_blendMode;				//!< How to blend.
            float					  m_blendFactor;			//!< Blend factor.
            U32						  m_numChannelFactorGroups;	//!< Number of joint factor groups;  0 to use only m_blendFactor, JointHierarchy::m_numChannelGroups required otherwise.
			U32						 *m_numChannelFactors;		//!< Number of joint factors per group.
            struct ChannelFactor	**m_channelFactorGroup;		//!< Since animations are done in groups of 128 channels, each group must have its own joint-factor table.
        };

		//----------------------------------------------------------------------------------------

        /*!
         * A flip node indicates that we want to flip all local joint spaces of the
         * hierarchy in a certain direction.
         *
		 * Joints are specified using offsets relative to the current joint group -
		 * offset = ((joint_index % kJointGroupSize) * sizeof(JointParams)).  All offsets
		 * are therefore between 0 and ((kJointGroupSize-1) * sizeof(JointParams) == 0x17d0),
		 * although no-ops with kFlipOpNop included to pad unary flips into pairs may safely
		 * point at any offset.
		 *
		 * Note that FlipNodes can not affect float channel data.
		 */
        struct FlipNode : public AnimationNode
        {
			AnimationNode	 *m_subTree;           //!< Pointer to animation nodes to perform the flip on.
            U16				  m_flipType;          //!< FlipType : kFlipUnary or kFlipBinary
			U16				 *m_numFlips;          //!< Pointer to array: m_numFlips[numJointGroups]  (elements must be multiple of 2 if Unary: fill with kFlipOpNop).
            U32				**m_flipOps;           //!< Pointer to array of arrays: m_flipOps[numJointGroups][ m_numFlips[iGroup] ] (elements may be nullptr if m_numFlips[i] == 0)
            U16				**m_jointOffsets;      //!< Pointer to array of arrays: m_jointOffsets[numJointGroups][ m_numFlips[iGroup] (*2 if kFlipBinary) ] (elements may be nullptr if m_numFlips[i] == 0)
        };

		//----------------------------------------------------------------------------------------
		class WorkBuffer;
		class CommandStream;

		//! Signiture of a UnaryPlugInNode batch mode callback
		typedef bool (*UnaryPlugInNodeBatchCallback)(		class BatchJob::WorkBuffer&, class BatchJob::CommandStream&,
															struct BlendGroupDesc const& groupDesc,
															Location const* pChannelGroupLoc, ValidBits* pValidOutput,
															void *pContext);
		//! Signiture of a UnaryPlugInNode immediate mode callback
		typedef bool (*UnaryPlugInNodeImmediateCallback)(	class BatchJob::WorkBuffer&, void* pWorkBufferMemory,
															struct BlendGroupDesc const& groupDesc,
															void*const* ppChannelGroup, ValidBits* pValidOutput,
															void *pContext);
		//! Signiture of a BinaryPlugInNode batch mode callback
		typedef bool (*BinaryPlugInNodeBatchCallback)(		class BatchJob::WorkBuffer&, class BatchJob::CommandStream&,
															struct BlendGroupDesc const& groupDesc,
															Location const* pLeftChannelGroupLoc, Location const* pRightChannelGroupLoc,
															Location const* pOutputChannelGroupLoc,
															ValidBits const* pLeftValid, ValidBits const* pRightValid,
															ValidBits* pValidOutput,
															void *pContext);
		//! Signiture of a BinaryPlugInNode immediate mode callback
		typedef bool (*BinaryPlugInNodeImmediateCallback)(	class BatchJob::WorkBuffer&, void* pWorkBufferMemory,
															struct BlendGroupDesc const& groupDesc,
															void const*const* ppLeftChannelGroup, void const*const* ppRightChannelGroup,
															void*const* ppOutputChannelGroup,
															ValidBits const* pLeftValid, ValidBits const* pRightValid,
															ValidBits* pValidOutput,
															void *pContext);

		/*
		 * To insert a call to custom code as a part of the AnimationNode tree, simply insert a
		 * UnaryPlugInNode or BinaryPlugInNode at the desired location, and a callback will be
		 * generated providing full context at that point in the blending phase.
		 *
		 * All plugin callbacks should return true unless a memory allocation failure or other
		 * serious error prevents them from completing.
		 *
		 * In SPU batched mode the batch callback is passed a WorkBuffer and a CommandStream and
		 * has the opportunity to insert a call to custom code into the command stream by either
		 * calling commandStream.CreateInlinePlugInCommand() or
		 * commandStream.CreateUploadCommand() and commandStream.CreatePlugInCommand().
		 * An inline command call must be able to fit all of its code and input data in one into
		 * one input buffer (about 23.75K); inline command code does not require space and will
		 * not persist in the work buffer.  Non-inline calls are required if code must persist
		 * for a later call or if code will not fit with input data in an input buffer.  To
		 * allocate space for code, call workBuffer.AllocHigh() to receive a handle to allocated
		 * space that can be passed to commandStream.CreateUploadCommand().  A later call to
		 * workBuffer.Free() will release the allocation.
		 *
		 * In PPU batched mode, the sequence is identical, except that you must construct
		 * a PPU code buffer with CommandStream::CreateCodeBufferForPpu(), which will connect
		 * each SPU code entry point to a PPU equivalent function matching the
		 * CommandStream::PpuPlugInFunction signiture.
		 *
		 * In immediate mode, the immediate callback is passed a WorkBuffer and a pointer to
		 * the work buffer memory, which can be used with workBuffer.LocationToPointer() and other
		 * functions to access the contents of the workbuffer.  In this case,
		 * the callback should execute its PPU substitute code immediately.
		 *
		 * In either case, the callback is passed a description of which joints and float channels
		 * are being worked on in a BlendGroupDesc.  The callback should return true unless
		 * the work buffer does not have memory sufficient to execute the plugin.
		 *
		 * Note that operations performed on the ValidBits structures must mirror those that will
		 * be performed by the custom code on the ValidBits associated with each channel group.
		 * The associated ValidBits can be retrieved with GetBlendGroupJointValidBits() and
		 * GetBlendGroupFloatChannelValidBits().
		 */

		/*!
		 * A UnaryPlugInNode represents a custom leaf or unary operation applied during the animation
		 * blending phase to either generate a pose with no inputs, or modify an input pose in place.
		 * It is thus passed an array of groupDesc.m_numChannelGroups channel group pointers to be
		 * updated in place, and an array of groupDesc.m_numChannelGroups ValidBits to be updated in
		 * place, in addition to other context.
		 */
		struct UnaryPlugInNode : public AnimationNode {
			AnimationNode						 *m_subTree;			//!< Pointer to input pose, or NULL if no inputs
			void								 *m_context;			//!< User context for the UnaryPlugInNode*Callback
			UnaryPlugInNodeBatchCallback		  m_batchCallback;		//!< A callback function that will handle submitting a call to custom code to a command stream
			UnaryPlugInNodeImmediateCallback	  m_immediateCallback;	//!< A callback function that will handle executing a call to custom code on the PPU
		};
		/*!
		 * A BinaryPlugInNode represents a custom binary operation applied during the animation
		 * blending phase to combine two input poses and output in place to one of them.
		 * It is thus passed two arrays of channel group input pointers and one of output pointers
		 * (which will always match one of the inputs) and the associated two arrays of input ValidBits
		 * and one of output ValidBits, in addition to other context.
		 */
		struct BinaryPlugInNode : public AnimationNode
		{
			AnimationNode						 *m_left;				//!< Pointer to first input pose
			AnimationNode						 *m_right;				//!< Pointer to second input pose
			void								 *m_context;			//!< User context for the UnaryPlugInNode*Callback
			BinaryPlugInNodeBatchCallback		  m_batchCallback;		//!< A callback function that will handle submitting a call to custom code to a command stream
			BinaryPlugInNodeImmediateCallback	  m_immediateCallback;	//!< A callback function that will handle executing a call to custom code on the PPU
		};

		// ===================================================================================================================

		/*! Signiture of a batch mode AnimationPlugInCall callback, which will receive a call when
		 *	construction of a batched task reaches a specified phase.
		 *
		 *  All plugin callbacks should return true unless a memory allocation failure or other
		 *	serious error prevents them from completing.
		 */
		typedef bool (*PlugInBatchCallback)(	class BatchJob::WorkBuffer&, class BatchJob::CommandStream&, JointHierarchy const* pHierarchy, void *pContext);
		/*!	Signiture of an immediate mode AnimationPlugInCall callback, which will receive a call when
		 *	immediate mode execution of a task reaches a specified phase.
		 *
		 *	All plugin callbacks should return true unless a memory allocation failure or other
		 *	serious error prevents them from completing.
		 */
		typedef bool (*PlugInImmediateCallback)(class BatchJob::WorkBuffer&, void *pWorkBufferMemory, JointHierarchy const* pHierarchy, void *pContext);

		//! Phases of animation available for call backs
		enum AnimationPhase {
			kPhasePostBlend,				//!< After blend nodes; working data: JointParams[pHierarchy->m_numAnimatedJoints], float channels float[pHierarchy->m_numFloatChannels]
			kPhasePreSdkFunction,			//!< After Sdk input commands; working data: as above + ScalarTable input scalars
			kPhasePreSdkDriven,				//!< After Sdk function commands; working data: as above + ScalarTable output scalars
			kPhasePrePrimaryParenting,		//!< Before primary parenting; working data: as above - float channels
			kPhasePostPrimaryParenting,		//!< After primary parenting; working data: as above + JointTransforms[pHierarchy->m_numPrimaryJoints]
			kPhasePreConstraints,			//!< if (pHierarchy->m_numSets > 1 && pHierarchy->m_numConstraintCommands), before constraints; working data: as above + SDK vector table + output ScalarTable, JointParams[pHierarchy->m_numTotalJoints] (minus constrained params)
			kPhasePostConstraints,			//!< if (pHierarchy->m_numSets > 1 && pHierarchy->m_numConstraintCommands), after constraints; working data: as above + JointParams[pHierarchy->m_numTotalJoints] (complete)
			kPhasePreSecondaryParenting,	//!< if (pHierarchy->m_numSets > 1), before secondary parenting; working data: as kPhasePostConstraints
			kPhasePostSecondaryParenting,	//!< if (pHierarchy->m_numSets > 1), after secondary parenting; working data: as above + JointTransform[pHierarchy->m_numTotalJoints] - SDK vector table - ScalarTable
			kPhasePreFinalize,				//!< Before finalize; working data: JointParams, JointTransform[pHierarchy->m_numTotalJoints]
		};

		/*!
		 *	To insert calls to custom code outside of the blending phase, create an
		 *	array of one or more AnimationPlugInCall structures in your AnimationControl in
		 *	m_plugIns, m_numPlugIns, ordered in AnimationPhase enum order.  More than
		 *	one plugin may be associated with each phase.
		 *
		 *	Each AnimationPlugInCall will create a callback at the requested phase during
		 *	the animation process.  The callback will receive the full context at that
		 *	point, in the form of a WorkBuffer containing a map of the current contents
		 *	of the work buffer, and either a CommandStream (in batched mode) or a pointer
		 *	to the memory location of the work buffer (in immediate mode).
		 */
		struct AnimationPlugInCall {
			AnimationPhase			 m_phase;				//!< animation phase to execute in
			PlugInBatchCallback		 m_batchCallback;		//!< callback if in batched mode (SPU or PPU)
			PlugInImmediateCallback	 m_immediateCallback;	//!< callback if in immediate mode
			void mutable			*m_context;				//!< context passed to callback
		};

		// ===================================================================================================================
#if ICEANIM_PERFORMANCE_STATS
		/*! Structure to hold performance statistics collected by the batch manager. */
		struct PerfStats {
			U32 bytesSent;					//!< total bytes sent to SPU
			U32 bytesRecd;					//!< total bytes received from SPU
			U32 bytesSentBlocks;			//!< bytesSent, taking into account 128 byte block access
			U32 bytesRecdBlocks;			//!< bytesRecd, taking into account 128 byte block access
			// PPU batching times in seconds
			F32 fTimeEvalNodes;				//!< time to batch task nodes
			F32 fTimeEvalSdks;				//!< time to batch sdk and constraint commands
			F32 fTimeParentingAndFinalize;	//!< time to batch parenting and finalize commands
			// PPU EvalNodes times in seconds
			F32 fTimeEvalClipNodes;			//!< time spent batching clip commands
			F32 fTimeEvalBlendNodes;		//!< time spent batching blend commands
		};
#endif

		/*!
		 *	Structure to hold pointers to buffers related to an instance of an animated object.
		 */
		struct AnimationControl {
			Ice::Anim::AnimationNode const	*rootNode;				//!< Input: animation tree root node.
			F32 const						*inputControls;			//!< Input: pointer to buffer containing float[JointHierarchy::m_numInputControls], or NULL
			SMath::Transform				*resultTransforms;		//!< Output: pointer to buffer for Transform[JointHierarchy::m_numTotalJoints], or NULL
			F32								*outputControls;		//!< Output: pointer to buffer for float[JointHierarchy::m_numOutputControls], or NULL

			U32								 numPlugInCalls;		//!< Input: number of plugin calls allocated in pPlugInCalls
			AnimationPlugInCall	const		*pPlugInCalls;			//!< Input: array of AnimationPlugInCall[numPlugInCalls], or NULL if numPlugInCalls==0
#if ICEANIM_PERFORMANCE_STATS
			PerfStats						*perfStats;				//!< Output: performance stats for this object.  (NOTE: perfStats.perfTimers will not be valid until task completes)
#endif
		};

		/*!
		 * Prepare an animation node tree for animation.  Returns 0 on if the tree is invalid.
		 *
		 * Implemented in iceanimbatched.cpp.
		 */
		U32 PreprocessAnimationNodes(Ice::Anim::AnimationNode *rootNode);

		/*!
		 * Create an animation task for batch SPU or PPU execution from the
		 * the given hierarchy and instance data provided in animControl and
		 * objectTransform.
		 *
		 * animControl->rootNode should be prepared with PreprocessAnimationNodes()
		 * or AnimationStack::FinalizeStack() using the AnimationStack helper defined in
		 * ice/anim/iceanimstack.h, and the other members of animControl should be
		 * initialized to point at valid output or input buffers, to return the resulting
		 * transform and optional sdk output data and input optional sdk control data.
		 *
		 * Uses pBatchMemory to allocate space for the animTask data.  No input, output,
		 * or allocated data should be touched from the time the task is run until it has
		 * completed if run on the SPU.
		 *
		 * To run tasks, see "ice/anim/iceanimtaskman.h":
		 * On the PPU, tasks can be run immediately with RunAnimationTaskOnPpu().
		 * On the SPU, a block of tasks must be defined by calling BeginSpuAnimationTasks()
		 * before, calling AddSpuAnimationTask one or more times, and calling
		 * EndSpuAnimationTasks() to define the end of the block.
		 * Tasks will begin running immediately after AddSpuAnimationTask is called, but
		 * may continue running after EndSpuAnimationTasks().  WaitForSpuAnimationTask(pTask)
		 * or IsSpuAnimationTaskComplete(pTask) may be used to check for the completion of
		 * one task at any time.  WaitForSpuAnimationTasks() or IsSpuAnimationTasksComplete()
		 * may be called after EndSpuAnimationTasks() to wait for all the tasks in the
		 * block to complete.
		 * Currently, only one block of animation tasks can be outstanding at a time.
		 *
		 * Implemented in iceanimbatched.cpp.
		 */
        bool AnimateJointsBatched(AnimationTask *animTask,						// Output: filled out with animation task data
								  AnimationControl const *animControl,			// Input: buffers for input/output of external data associated with this object
								  JointHierarchy const *hierarchy, 				// Input: joint hierarchy
								  SMath::Transform const &objectTransform,      // Input: object transform
								  BatchJob::MemoryBuffer *pBatchMemory);		// Input/Output: memory used for batching

		/*!
		 * Identical to AnimateJointsBatched, except that the task created will not
		 * perform parenting, sdks, or constraints, and will not output matrices to
		 * animControl->resultTransforms, or sdk results to animControl->sdkResults.
		 *
		 * This is specifically useful in combination with an animation task with a
		 * snapshot node as the root node, allowing an animation task to be broken
		 * into two parts - a first pass task which outputs a pose resulting from a
		 * set of clip and blend commands to the space pointed to in a snapshot
		 * node, and a second pass task to perform parenting, sdks, constraints, and
		 * output to matrices, which will typically be passed a simple animation
		 * task with a single pose node pointing to the data returned to the
		 * snapshot node by the first pass.
		 *
		 * Breaking the task up in this way allows the caller to apply custom
		 * modifications to the pose - complicated constraints or procedural
		 * animation not supported by the animation system, for instance - before
		 * parenting or sdks have run.
		 *
		 * Implemented in iceanimbatched.cpp.
		 */
		bool AnimateJointsBlendOnlyBatched(AnimationTask *animTask,					// Output: filled out with animation task data
										   AnimationControl const *animControl,		// Input: buffers for input/output of external data associated with this object
										   JointHierarchy const *hierarchy,			// Input: joint hierarchy
										   BatchJob::MemoryBuffer *pBatchMemory);	// Input/Output: memory used for batching

		/*!
		 * Run immediate animation on the PPU based on the given hierarchy and animation
		 * node tree stemming from rootNode.  Uses the the buffers provided in animControl
		 * to return resultTransforms and additionalSdkResults immediately.
		 *
		 * Implemented in iceanimimmediate.cpp.
		 */
        bool AnimateJoints(AnimationControl const *animControl,					// Input: buffers for input/output of external data associated with this object
						   JointHierarchy const *hierarchy,						// Input: joint hierarchy
						   SMath::Transform const &objectTransform);			// Input: object transform

		/*!
		 * Run immediate animation on the PPU based on the given hierarchy and animation
		 * node tree stemming from rootNode.
		 *
		 * As in AnimateJointsBlendOnlyBatched, does not perform parenting, sdks, or
		 * constrains or return transforms or sdkresults, but may be useful when
		 * invoked with a snapshot node to allow access to the pose before parenting
		 * and sdks are run.
		 *
		 * Implemented in iceanimimmediate.cpp.
		 */
		bool AnimateJointsBlendOnly(AnimationControl const *animControl,		// Input: buffers for input/output of external data associated with this object
									JointHierarchy const *hierarchy);			// Input: joint hierarchy

		/*!
		 * Print out the contents of the given hierarchy for debugging purposes.
		 *
		 * Implemented in iceanimdump.cpp.
		 */
		void DumpJointHierarchy(Ice::Anim::JointHierarchy const *hierarchy, bool verbose = false, int indent = 0);
		/*!
		 * Print out the contents of the given clip for debugging purposes.
		 *
		 * Implemented in iceanimdump.cpp.
		 */
        void DumpClipData(Ice::Anim::ClipData const *clip, bool verbose = false, int indent = 0);
	}
};

#endif //ICE_ICEJOINTANIM_H
