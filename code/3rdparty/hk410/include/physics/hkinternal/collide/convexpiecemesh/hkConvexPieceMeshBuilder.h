/* 
 * 
 * Confidential Information of Telekinesys Research Limited (t/a Havok).  Not for disclosure or distribution without Havok's
 * prior written consent.This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Level 2 and Level 3 source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2006 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 * 
 */

#ifndef HK_INTERNAL_CONVEXPIECEMESH_BUILDER_H
#define HK_INTERNAL_CONVEXPIECEMESH_BUILDER_H

#include <hkmath/hkMath.h>
#include <hkbase/htl/hkObjectArray.h>
#include <hkbase/htl/hkPointerMap.h>
#include <hkcollide/agent/hkProcessCollisionInput.h>
#include <hkinternal/collide/convexpiecemesh/hkConvexPieceStreamData.h>
#include <hkcollide/shape/collection/hkShapeCollection.h>

#include <hkcollide/agent/hkLinearCastCollisionInput.h>

class hkClosestCdPointCollector;
class hkTriangleShape;
class hkMeshShape;

//#include <hkvisualize/shape/hkDisplayGeometry.h>


/// This is a helper class which allows the hkConvexPieceMeshBuilder to query the material of individual childShapes 
/// of the hkCollectionShape being converted to convex pieces. hkConvexPieceMeshBuilder only merges childShapes
/// having the same material information.
class hkShapeCollectionMaterialMediator
{
	public:

		virtual ~hkShapeCollectionMaterialMediator() { }
			/// Gets material ID for the child shape specified.
		virtual hkUint32 getMaterialOfShapeKey(hkShapeKey key) const = 0;
};

/// This implementation returns hkMeshMaterial::m_filterInfo associated with child shapes.
class hkDefaultShapeCollectionMaterialMediator : public hkShapeCollectionMaterialMediator
{
	public:
		hkDefaultShapeCollectionMaterialMediator(hkMeshShape* meshShape) ;
		~hkDefaultShapeCollectionMaterialMediator();

			/// Gets the hkMeshMaterial::m_filterInfo of the specified child shape.
		hkUint32 getMaterialOfShapeKey(hkShapeKey key) const;

	private:
		hkMeshShape* m_meshShape;
};


///
/// Given a triangle based mesh, this class creates a simplified set of convex pieces 
/// representing the same mesh.
///
///
/// The output can be passed to the hkConvexPieceMeshShape which can then be wrapped in a
/// hkMoppBvTreeShape and used as the simulation mesh in a game.
/// 
class hkConvexPieceMeshBuilder: public hkReferencedObject
{
	public:
		HK_DECLARE_CLASS_ALLOCATOR(HK_MEMORY_CLASS_CDINFO);


			/// Constructs a new hkConvexPieceMeshBuilder.
		hkConvexPieceMeshBuilder();

			/// Destructs any mem allocated etc
		~hkConvexPieceMeshBuilder();


			/// Creates a convex representation of the input mesh.
			/// The displayMesh must be a shapeCollection that returns 
			/// children of type "hkTriangleShape".
			/// 
			/// The maximum number of triangles in each convex piece can be
			/// specified here also.  If maxTrianglesPerConvexPiece is -1, the max number
			/// of vertices that will fit in the shape buffer will be used.
		void convexifyLandscape( const hkShapeCollection* inputMesh, hkCollisionInput* collisionInput, hkConvexPieceStreamData& convexPieceStreamDataOut, hkShapeCollectionMaterialMediator* materialMediator = HK_NULL, int maxVerticesPerConvexPiece = -1 );


	protected:

		struct TriangleInfo
		{
			HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR(HK_MEMORY_CLASS_CDINFO, TriangleInfo);
	
			char m_flags;
			hkBool m_vertsUsed[3];
			//hkUint16 m_lightInfo; /*HK_TRIANGLELIGHT_INFO*/

			// members used by the lighting algorithm
			int m_convexPieceOffset;
		};

			///
		struct BuilderInput
		{
			HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR(HK_MEMORY_CLASS_CDINFO, BuilderInput);

			hkCollidable* m_moppCollidable;
			hkCollidable* m_sphereCollidable;
			hkReal m_sphereRadius;
			hkTransform* m_sphereTransform;
			const hkShapeCollection* m_meshShape;
			const hkShapeCollectionMaterialMediator* m_materialMediator;
			hkPointerMap<hkShapeKey, hkUint32> m_shapeKeyToTriangleInfoIndex;
			hkArray< struct TriangleInfo > m_triangleInfo;
			struct hkLinearCastCollisionInput m_collisionInput;

			BuilderInput() : m_moppCollidable(HK_NULL), m_sphereCollidable(HK_NULL),
			m_sphereRadius(0.0f), m_sphereTransform(HK_NULL) {}

			~BuilderInput() 
			{
				m_moppCollidable->getShape()->removeReference();
				delete m_moppCollidable;
				delete m_sphereCollidable;
				delete m_sphereTransform;
			}

		};


		/// Internal struct used to represent a convex piece.
		struct ConvexPiece
		{
			HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR(HK_MEMORY_CLASS_CDINFO, ConvexPiece);

			///
			hkArray<hkShapeKey> m_triangles;

			/// We store the vertices used in the convex piece here, since these
			/// are generated by calculating the convex hull of the convex piece.
			hkArray<hkVector4> m_vertices;

			/// Set true if this convex piece is not to be modified, e.g. it has
			/// been determined that this is the largest convex piece possible
			/// containing any of the triangles it has.
			hkBool m_fixedConvexPiece;

			/// There is also a bitfield in the triangleInfo for each triangle
			/// that indicates which vertices in that triangle are used here.
			char m_flags;

			ConvexPiece() : m_fixedConvexPiece(false), m_flags(0) {}
		};

	protected:

		hkBool isEqualNormal( const hkTriangleShape* triangle, const hkTriangleShape* neighbourTriangle, hkVector4& triNormal );

		void linearCastAgainstCentroid( hkConvexPieceMeshBuilder::BuilderInput& input, const hkVector4& source, const hkShapeKey& triKey, hkClosestCdPointCollector& collector );

		void calcCentroidAndNormal( hkConvexPieceMeshBuilder::BuilderInput& input, const hkShapeKey& triKey, hkVector4& centroid, hkVector4& triNormal );

		hkBool canAssimilateVertex( const hkShapeCollection* meshShape, const ConvexPiece& convexPiece, const hkVector4& vertex,
									const hkVector4& edge0, const hkVector4& edge1, const hkVector4& triNormal );

		hkBool notEdgeVert( const hkVector4& vert1, const hkVector4& vert2, const hkVector4& vert3 );

		hkBool canJoinConvexShapeToConvexShape( const hkShapeCollection* meshShape, const hkShapeCollectionMaterialMediator* materialMediator,
													const ConvexPiece& convexPiece, const ConvexPiece& neighbourConvexPiece );

		static inline TriangleInfo* getTriangleInfo(BuilderInput& input, hkShapeKey key);

		void buildBuilderInput(const hkShapeCollection* inputMesh, hkCollisionInput* collisionInput, hkConvexPieceMeshBuilder::BuilderInput& inputOut, hkShapeCollectionMaterialMediator* materialMeidator = HK_NULL);

		void getConvexPieceAabb( BuilderInput& input, const ConvexPiece& convexPiece, const hkTransform& localToWorld, hkReal tolerance, hkAabb& out ) const;

			/// Checks if the m_fixedConvexPiece flag has been set in the convex piece this triangle is in.
		hkBool isFixedTriangle( BuilderInput& input, const hkShapeKey key );

		hkBool isNotDegenerateTriangle( BuilderInput& input, const hkShapeKey key );

		hkBool isGoodTriangle( BuilderInput& input, const hkShapeKey key );

		void joinFlatTriangles( BuilderInput& input );

		void filterCollinearVertices( BuilderInput& input, ConvexPiece& convexPiece );
		void generatePlaneEquationsForConvexPiece( BuilderInput& input, ConvexPiece& convexPiece, hkArray< hkVector4 >& planeEquations, hkBool runExtraCollinearFilter );

	protected:

		//
		// Optimised bit stream structure.
		//

		void convertArraysToStream( hkConvexPieceMeshBuilder::BuilderInput& input,
									hkConvexPieceStreamData& convexPieceMeshOut );

		int calcStreamSize( const hkArray< ConvexPiece* >& convexPieces );

			/// Build the stream data from the input arrays.
		void buildStreamData( hkConvexPieceMeshBuilder::BuilderInput& input,
								const hkArray< ConvexPiece* >& convexPieces, 
								hkArray< hkUint32 >& stream, 
								hkArray< hkUint32 >& convexPieceOffsets,
								hkArray< hkUint32 >& convexPieceSingleTriangles );

		void deallocatePieces();

		// Intermediate structure used during construction of convex pieces.
		hkArray<struct ConvexPiece*>	m_convexPieces;

		int m_maxVerticesPerConvexPiece;

	public:
		hkConvexPieceMeshBuilder( hkFinishLoadedObjectFlag flag ) {}

};


#endif // HK_INTERNAL_CONVEXPIECEMESH_BUILDER_H

/*
* Havok SDK - PUBLIC RELEASE, BUILD(#20060902)
*
* Confidential Information of Havok.  (C) Copyright 1999-2006 
* Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
* Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
* rights, and intellectual property rights in the Havok software remain in
* Havok and/or its suppliers.
*
* Use of this software for evaluation purposes is subject to and indicates 
* acceptance of the End User licence Agreement for this product. A copy of 
* the license is included with this software and is also available from salesteam@havok.com.
*
*/
