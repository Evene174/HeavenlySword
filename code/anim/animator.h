/***************************************************************************************************
*
*	$Header:: /game/animator.h 12    12/08/03 13:31 Dean                                           $
*
*	Animation Blending & Control
*
*	CHANGES
*
*	24/3/2003	Dean	Created
*
***************************************************************************************************/

#ifndef	ANIM_ANIMATOR_H_
#define	ANIM_ANIMATOR_H_

// Necessary includes
#include "anim/animevents.h"
#include "anim/AnimationHeader.h"
#include "Gp/GpAnimator/GpAnimatorBatch.h"

// Forward declarations
class	CHierarchy;
class	CEntity;
class	EntityAnimSet;

/***************************************************************************************************
*
*	ENUMERATION		CAnimator Flags
*
*	DESCRIPTION		Flags for the CAnimator object.
*
***************************************************************************************************/
enum ANIMATOR_FLAGS
{
	ANIMATORF_HAS_DELTAS_AVAILABLE		= ( 1 << 0 ),
	ANIMATORF_APPLY_DELTAS_EXPLICITY	= ( 1 << 1 ),
	ANIMATORF_SIMPLE_ANIMATOR			= ( 1 << 2 ),		// A "simple animator" is one that will never check for locomotion or relative anims.
};

/***************************************************************************************************
*
*	CLASS			CAnimator
*
*	DESCRIPTION		This object controls all animations playing back on a particular hierarchy.  It
*					is created through a static construction function, which allows us to reduce
*					memory allocation overheads by combining hierarchy-specific allocations into
*					the same object as the CAnimator itself. We use this technique in the CAnimation
*					class too.
*
***************************************************************************************************/
ALIGNTO_PREFIX( 128 ) class CAnimator
{
	public:
		// Construction & destruction
		static	CAnimator *	Create					(	EntityAnimSet *	animShortCuts,
														CHierarchy *					hierarchy,
														CEntity *						parentEntity			= NULL,		// Create an animator from core data.
														bool							has_user_data_channels	= false		// Allows us to pull out user data channels.
													);

		static	void		Destroy					( CAnimator* pAnimator );

		// The ability to kill the functionality of this component
		void 				Enable					()						{ m_bEnabled = true; }
		void 				Disable					()						{ m_bEnabled = false; }
		bool 				IsEnabled				()	const				{ return m_bEnabled; }

		// Access to the animators flags - strange mix of stuff here, some used internally and changed each frame,
		// some external and constant - should be split up if they are all to be used - GH
		int32_t				GetFlags				()	const				{ return m_Flags; }
		void				SetFlags				( int32_t flags )		{ m_Flags = flags; }
		void				SetFlagBits				( int32_t flag_bits )	{ m_Flags |= flag_bits; }
		void				ClearFlagBits			( int32_t flag_bits )	{ m_Flags &= ~flag_bits; }

		// Retrieve root locomotion data generated by the previous update of this animator
		CQuat				GetRootRotationDelta	() 	const				{ return m_obRootRotationDelta; }
		CPoint				GetRootTranslationDelta	() 	const				{ return m_obRootTranslationDelta; }

		// Get some abstract tracking data
		CVector				GetTrackingData			( int32_t iTransform ) const;
		
		// Access to the phase of the animator ( 0.0f if no linked animations ).  The set phase was used by JB's initial
		// data-heavy movement system.  Currently this is not being used but i have left the functionality because
		// as is not costly.  I would question its use in future - maybe a just a Reset would be a good abstraction - GH
		float				GetPhasePosition		()	const				{ return m_fPhasePosition; }
		
		// Get the heirarchy that this animator is acting on - used by anim events - ideally shouldn't be, go through the entity - GH
		const CHierarchy *	GetHierarchy			()	const				{ return m_pobHierarchy; }

		// Create me an animation, please
		CAnimationPtr		CreateAnimation			( const CHashedString& shortName );

		// STOPGAP HACK - shouldn't need this once animevents are rationalised a wee bit
		CAnimEventHandler &	GetAnimEventHandler		()			{ return m_obAnimEventHandler; }

		// Code for replicating animator state across a network
		bool				IsPlayingAnimation		( uint32_t uiAnimHash ) const;
		CAnimationPtr		GetPlayingAnimation		( uint32_t uiAnimHash );

		bool				IsPlayingAnimation		( CAnimationPtr pAnim ) const;


		// Bone clamping functionality.
		typedef ntstd::Vector< ntstd::pair< int, int > > ChildToParentBoneMappingArray;
		inline void			SetBonesToClamp			( const ChildToParentBoneMappingArray &child_to_parent_bone_map, const CAnimator *entity_to_clamp_to );

		// Code for enumerating animations.
		uint32_t			GetNumAnimations		()				const	{ return m_NumAnimations; }
		const CAnimationPtr	GetAnimation			( uint32_t i )	const	{ ntError( i < m_NumAnimations ); return m_Animations[ i ]; }

		// The main update of this entity component. Returns true if update is required.
		bool				CreateBlends			( float fTimeStep, bool batched = false );

		// The pre-render update.
		void				UpdateResults			();
		
		// For adding and removing animations from an animator.
		// AddAnimation returns true if the animation was added, false if there was no room for the animation.
		bool				AddAnimation			( const CAnimationPtr &pobAnimation );		
		void				RemoveAnimation			( const CAnimationPtr &pobAnimation );					
		void				RemoveAllAnimations		();

		// Remove all animations whose blend-weight is less than "min_valid_weight".
		void				RemoveAllAnimationsBelowWeight	( float min_valid_weight );
		
		// This sets all the anim weights that can be set to zero so that systems like movement can have no influence as default 
		void				ClearAnimWeights		();

		// This is a TEMPORARY function for Giles only.. please don't use it without prior consultation
		bool				IsPlayingAnimation		()	const	{ return ( m_NumAnimations > 0 ); }

		// Used by the game audio for foot fall - nasty?
		const CAnimationPtr	GetPredominantAnim		()	const;

		// Debug print animations in the list	
		void				DebugPrint				() const;

		// Debug render print animations in the list
		void				DebugRenderPrint		( float fX, float fY, uint32_t ulColour ) const;

		// Speculative relative animation stuff - GILES
		CPoint		GetRelativeMovementPosition		() 	const 	{ return m_obRelativeMovementPos; }
		CQuat		GetRelativeMovementRotation		() 	const 	{ return m_obRelativeMovementRot; }
		bool		HasRelativeMovement				() 	const 	{ return m_bRelativeMovement; }
		float		GetRelativeMovementWeight		() 	const 	{ return m_fRelativeMovementWeight; }

		// Return the ATG GpAnimator object. DO NOT CALL OUTSIDE OF THE ANIMATION SYSTEM.
		GpAnimator *		GetGpAnimator			()			{ return m_AnimatorData; }
		const GpAnimator *	GetGpAnimator			()	const	{ return m_AnimatorData; }

	private:
		// Single function responsible for detaching an animation currently set to an animator
		void				DetachAnimation			( const CAnimationPtr &pobAnimation );

		// Private construction - use Create to make one
		CAnimator();	

		// Private destruction - use Destroy to kill
		~CAnimator();

	private:
		//
		//	Don't allow copying.
		//
		CAnimator( const CAnimator & )					NOT_IMPLEMENTED;
		CAnimator & operator = ( const CAnimator & )	NOT_IMPLEMENTED;

	private:
		//
		//	Data members.
		//
		CQuat							m_obRootRotationDelta;						// Locomotion : Rotational delta for root transform.
		CPoint							m_obRootTranslationDelta;					// Locomotion : Translational delta for root transform
		CPoint							m_obRelativeMovementPos;					// Speculative relative animation stuff.
		CQuat							m_obRelativeMovementRot;					// Speculative relative animation stuff.

		CQuat							m_LocalRootRotation;						// We need to take a copy of this for relative anims.
		CPoint							m_LocalRootTranslation;

		CAnimEventHandler				m_obAnimEventHandler;						// Handler for events triggered by animations
		ChildToParentBoneMappingArray	m_ChildToParentBoneMappingArray;

		const CAnimator *				m_AnimatorToClampTo;						// Can be NULL.
		CHierarchy *					m_pobHierarchy;								// Pointer to the owning hierarchy (needed to update it).
		EntityAnimSet *	m_AnimShortCutContainer;					// A pointer to the animations that this animator can create and use

		GpAnimator *					m_AnimatorData;								// The ATG animator object - contains blending results and does all the work.

		static const uint32_t			MaxNumAnims	= 40;							// Maximum number of animations allowed per-animator.
		CAnimationPtr 					m_Animations[ MaxNumAnims ];				// A list of CAnimationPtr objects (priority order)
		uint32_t						m_NumAnimations;

		int32_t							m_Flags;									// Flags, settings for the animator.
		float							m_fRelativeMovementWeight;					// Speculative relative animation stuff.
		float							m_fPhasePosition;							// What is the current phase position.
		float							m_fDebugLastFramePhase;						// This is to track changes in phase for debugging.

		bool							m_bOverridePhase;							// A flag to show whether the phase has been set directly this frame.
		bool							m_bEnabled;									// Allow this component to be turn on and off-able.
		bool							m_bRelativeMovement;						// Speculative relative animation stuff.
		bool							m_hasAnimEvents;							// Do we have any anim-events.
		bool							m_HasUserBindings;

}
ALIGNTO_POSTFIX( 128 );

class AnimatorBatchUpdate
{
	public:
		//
		//	Batching interface.
		//
					// Call this once before you loop through and add your animators.
		void		StartBatch();

					// Call this for each animator you want to add.
		void		AddAnimator( CAnimator *animator, float time_step );

					// Call this once after you've added all your animators to wait for
					// the results from the SPUs. NOTE: This function may stall the PPU.
		void		FinishBatch();

	public:
		//
		//	Ctor.
		//
		AnimatorBatchUpdate( uint32_t batch_size = 20 );

	private:
		//
		//	Helper functions.
		//
		void		InternalFinishBatch();
		void		CreateBlends();

	private:
		//
		//	Internal data.
		//
		static const uint32_t	NumBatches = 5;
		GpAnimatorBatch			m_AnimBatcher[ NumBatches * 2 ];
		uint32_t				m_BatchSize;
		uint32_t				m_CurrentBatch;
		uint32_t				m_BatchOffset;
		uint32_t				m_Counter;
		uint32_t				m_NumSetSwaps;
};

//
//	Inline functions.
//

/***************************************************************************************************
*
*	FUNCTION		CAnimator::SetBonesToClamp
*
*	DESCRIPTION		For each pair of integers (bone indices) in child_to_parent_bone_map, the first
*					integer is a bone index for this animator, the second is a bone index for the 
*					animator_to_clamp_to animator. The local transform from the passed in animator
*					that corresponds to each of the second indices in the map is copied over the
*					local transform corresponding to the same first index in the map. If that makes
*					any sense.
*
***************************************************************************************************/
inline void CAnimator::SetBonesToClamp( const ChildToParentBoneMappingArray &child_to_parent_bone_map, const CAnimator *animator_to_clamp_to )
{
	m_ChildToParentBoneMappingArray = child_to_parent_bone_map;
	m_AnimatorToClampTo = animator_to_clamp_to;
}



#endif // !ANIM_ANIMATOR_H_
