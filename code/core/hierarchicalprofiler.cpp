#ifdef _PROFILING

#include "core/hierarchicalprofiler.h"

#ifdef _HIERARCHICAL_PROFILER_TESTING
	// This hackery enables me to work on the profiler outside of the game code,
	// significantly decreasing the compile-link-run time between iterations. /Mats
	#include <windows.h>
	#define snprintf( a, b, c, d, e, f, g, h, i, j, k ) _snprintf( a, b, c, d, e, f, g, h, i, j, k );
	#define NT_NEW new
	#define NT_DELETE( ptr ) delete ptr

	class CTimer
	{
	public:
		static int64_t GetHWTimer()
		{
			LARGE_INTEGER stHWTimer;
			QueryPerformanceCounter( &stHWTimer );
			return (int64_t) stHWTimer.QuadPart;
		}

		static float GetHWTimerPeriod()
		{
			LARGE_INTEGER stFrequency;
			QueryPerformanceFrequency( &stFrequency );
			return 1.0f / ( float )( stFrequency.QuadPart );
		}
	};

	class Debug
	{
	public:
		static void AlwaysOutputString( const char* pString ) { printf( pString ); }
	};
#else
	#include "core/timer.h"
#endif // _HIERARCHICAL_PROFILER_TESTING


// Constants.
static const int OUTPUT_INDENTATION_SIZE = 2;				// Number of spaces per indentation level.
static const int OUTPUT_DECIMAL_PLACES = 3;					// Number of decimal places for time readings.
static const float OUTPUT_PRUNING_TIME_THRESHOLD = 0.1f;	// Readings that take less time than this will not be listed.


// Static member initializations.
HierarchicalProfiler::Sample* HierarchicalProfiler::s_pobSampleTree = NULL;
HierarchicalProfiler::Sample* HierarchicalProfiler::s_pobCurrentContext = NULL;
LogFile* HierarchicalProfiler::s_pobLogFile = NULL;
bool HierarchicalProfiler::s_bEnabled = true;


//--------------------------------------------------
//
//! Sorts the Samples in descending order based on their accumulated time.
//! 
//! \return		true if the second Sample should be placed above the first.
//
//--------------------------------------------------
bool HierarchicalProfiler::Sample::PointerSorter::operator()( const Sample* pobFirst, const Sample* pobSecond ) const
{
	if ( !pobFirst )
		return false;

	if ( !pobSecond )
		return true;

    return *pobSecond < *pobFirst;
}


//--------------------------------------------------
//
//! Creates a new named Sample and assigns its parent.
//! 
//! \param pLabel	Pointer to a C string constant. Generated by the LOAD_PROFILE() macro.
//! \param pParent	Pointer to a Sample to assign as this Sample's parent.
//
//--------------------------------------------------
HierarchicalProfiler::Sample::Sample( const char* pLabel, Sample* pParent )
	: m_iStartTime( 0 )
	, m_iAccumulatedTime( 0 )
	, m_pLabel( pLabel )
	, m_uiCallCount( 0 )
	, m_pobParent( pParent )
{
}


//--------------------------------------------------
//
//! Stores the current time inside this Sample.
//! 
//! \param iStartTime	Optional start time. Defaults to now.
//
//--------------------------------------------------
void HierarchicalProfiler::Sample::Start( int64_t iStartTime = CTimer::GetHWTimer() )
{
	IncreaseCallCount();
	
	if ( !IsRunning() )
		m_iStartTime = iStartTime;
}


//--------------------------------------------------
//
//! Stops this Sample, adding the elapsed time to its accumulated time counter.
//! 
//! \param iEndTime		Optional end time. Defaults to now.
//
//--------------------------------------------------
void HierarchicalProfiler::Sample::Stop( int64_t iEndTime = CTimer::GetHWTimer() )
{
	if ( IsRunning() )
	{
		m_iAccumulatedTime += iEndTime - m_iStartTime;
		m_iStartTime = 0;
	}
}


//--------------------------------------------------
//
//! Returns the accumulated time in this Sample up to this point.
//! 
//! \param iCurrentTime		Optional end time. Defaults to now.
//! \return					The accumulated time in this Sample up to this point.
//
//--------------------------------------------------
float HierarchicalProfiler::Sample::AccumulatedTime( int64_t iCurrentTime = CTimer::GetHWTimer() ) const
{
	return AsSeconds( IsRunning() ? m_iAccumulatedTime + ( iCurrentTime - m_iStartTime ) : m_iAccumulatedTime );
}


//--------------------------------------------------
//
//! Comparison operator. Compares the accumulated time of this Sample to another Sample.
//! 
//! \param obOther		The Sample to compare this Sample to.
//! \return				true if this Sample's accumulated time is less than the other Sample.
//
//--------------------------------------------------
bool HierarchicalProfiler::Sample::operator<( const Sample& obOther ) const
{
	return AccumulatedTime() < obOther.AccumulatedTime();
}


//--------------------------------------------------
//
//! Returns the number of calls to this Sample's scope.
//! 
//! \return		The number of calls to this Sample's scope.
//
//--------------------------------------------------
uint32_t HierarchicalProfiler::Sample::CallCount() const
{
	return m_uiCallCount;
}


//--------------------------------------------------
//
//! Returns this Sample's parent Sample, or NULL if this Sample does not have a parent.
//! 
//! \return		This Sample's parent Sample, or NULL if this Sample does not have a parent.
//
//--------------------------------------------------
HierarchicalProfiler::Sample* HierarchicalProfiler::Sample::Parent()
{
	return m_pobParent;
}


//--------------------------------------------------
//
//! Returns this Sample's parent Sample, or NULL if this Sample does not have a parent.
//! 
//! \return		This Sample's parent Sample, or NULL if this Sample does not have a parent.
//
//--------------------------------------------------
const HierarchicalProfiler::Sample* HierarchicalProfiler::Sample::Parent() const
{
	return m_pobParent;
}


//--------------------------------------------------
//
//! Returns a reference to a child Sample located directly below this Sample.
//! If no sample exists, a new Sample is created and added as a child of this Sample.
//! 
//! \return		A reference to a the child Sample.
//
//--------------------------------------------------
HierarchicalProfiler::Sample& HierarchicalProfiler::Sample::Child( const char* pLabel )
{
	for ( ChildList::iterator obChildIter = m_obChildren.begin(); obChildIter != m_obChildren.end(); ++obChildIter )
	{
		if ( obChildIter->m_pLabel == pLabel )
			return *obChildIter;
	}
	
	m_obChildren.push_back( Sample( pLabel, this ) );
	return m_obChildren.back();
}


//--------------------------------------------------
//
//! Returns a list of sorted pointers to the child Samples directly below this Sample.
//! The list is sorted by accumulated time, highest to lowest.
//! 
//! \return		A list of sorted Sample pointers.
//
//--------------------------------------------------
HierarchicalProfiler::SampleList HierarchicalProfiler::Sample::SortedChildren() const
{
	SampleList obResult;
	for (ChildList::const_iterator obChildIter = m_obChildren.begin(); obChildIter != m_obChildren.end(); ++obChildIter )
		obResult.push_back( &( *obChildIter ) );

	ntstd::sort( obResult.begin(), obResult.end(), PointerSorter() );
	return obResult;
}


//--------------------------------------------------
//
//! Backtracks along the call stack until it finds the named Sample. Returns NULL if no matching Sample was found.
//! 
//! \param pLabel	The label of the Sample to locate. Generated by the LOAD_PROFILE() macro, so we can simply compare pointers.
//! \return			A pointer to the matching Sample, or NULL if no matching Sample was found above this Sample.
//
//--------------------------------------------------
HierarchicalProfiler::Sample* HierarchicalProfiler::Sample::FindSampleAbove( const char* pLabel )
{
	Sample* pExaminedSample = this;
	while ( pExaminedSample )
	{
		if ( pExaminedSample->m_pLabel == pLabel )
			return pExaminedSample;
			
		pExaminedSample = pExaminedSample->Parent();
	}
	
	return NULL;
}


//--------------------------------------------------
//
//! Returns the number of Samples along the call stack above this Sample.
//! 
//! \return		The number of Samples along the call stack above this Sample.
//
//--------------------------------------------------
uint32_t HierarchicalProfiler::Sample::ParentCount() const
{
	uint32_t uiResult = 0;
	
	const Sample* pobParent = Parent();
	while ( pobParent )
	{
		++uiResult;
		pobParent = pobParent->Parent();
	}

	return uiResult - 1;
}


//--------------------------------------------------
//
//! Returns the width (in characters) of this Sample's label.
//! 
//! \return		The number of characters in this Sample's label.
//
//--------------------------------------------------
uint32_t HierarchicalProfiler::Sample::LabelWidth() const
{
	return m_pLabel ? static_cast< uint32_t >( strlen( m_pLabel ) ) : 0;
}


//--------------------------------------------------
//
//! Returns the width (in characters) of this Sample's label, including any spaces used for indentation to form a tree-structure.
//! 
//! \return		The number of characters in this Sample's label, including indenting spaces.
//
//--------------------------------------------------
uint32_t HierarchicalProfiler::Sample::IndentedLabelWidth() const
{
	return ParentCount() * OUTPUT_INDENTATION_SIZE + LabelWidth();
}


//--------------------------------------------------
//
//! Returns the width (in characters) of the widest label in or below this Sample.
//! 
//! \param bIndented	If true, returns the indented label width.
//! \return				The width (in characters) of the widest label in or below this Sample.
//
//--------------------------------------------------
uint32_t HierarchicalProfiler::Sample::WidestLabelColumnWidth( bool bIndented ) const
{
	uint32_t uiWidestLabelColumnWidth = bIndented ? IndentedLabelWidth() : LabelWidth();
	for ( ChildList::const_iterator obChildIter = m_obChildren.begin(); obChildIter != m_obChildren.end(); ++obChildIter )
		uiWidestLabelColumnWidth = ntstd::Max( uiWidestLabelColumnWidth, obChildIter->WidestLabelColumnWidth( bIndented ) );
		
	return uiWidestLabelColumnWidth;
}


//--------------------------------------------------
//
//! Outputs a formatted string containing this Sample's label, accumulated time and call count.
//! 
//! \param uiLabelColumnWidth	The width of the label column of the output. You can find out a good width using the WidestLabelColumnWidth() function.
//! \param bIndented			If true, the output will be indented by the number of samples above this Sample on the call stack.
//
//--------------------------------------------------
void HierarchicalProfiler::Sample::Output( uint32_t uiLabelColumnWidth, bool bIndented ) const
{
	if ( this == HierarchicalProfiler::s_pobSampleTree )
		return;

	float fAccumulatedTime = AccumulatedTime();
	if ( fAccumulatedTime >= OUTPUT_PRUNING_TIME_THRESHOLD )
	{
		static char pBuffer[ 256 ];
		uint32_t uiIndentSpaces = bIndented ? ParentCount() * OUTPUT_INDENTATION_SIZE : 0;
		snprintf( pBuffer, sizeof( pBuffer ), "%*s%-*s%10.*f seconds%10u call%s\n", uiIndentSpaces, "", uiLabelColumnWidth - uiIndentSpaces, m_pLabel, OUTPUT_DECIMAL_PLACES, fAccumulatedTime, CallCount(), CallCount() == 1 ? "" : "s" );
		OutputString( pBuffer );
	}
}


//--------------------------------------------------
//
//! Outputs a formatted tree of this Sample and all Samples below it, recursively.
//! 
//! \param uiLabelColumnWidth	The width of the label column of the output. You can find out a good width using the WidestLabelColumnWidth() function.
//
//--------------------------------------------------
void HierarchicalProfiler::Sample::OutputTree( uint32_t uiLabelColumnWidth ) const
{
	Output( uiLabelColumnWidth, true );
	for ( ChildList::const_iterator obChildIter = m_obChildren.begin(); obChildIter != m_obChildren.end(); ++obChildIter )
		obChildIter->OutputTree( uiLabelColumnWidth );
}



//--------------------------------------------------
//
//! Groups this Sample and all Samples below it by their labels, recursively.
//! All the accumulated times are added up, as are the call counts.
//! The resulting Samples with this information are added as children to the
//! specified receiving Sample.
//! 
//! \param obReceivingSample	The Sample that will be populated with the grouped data.
//
//--------------------------------------------------
void HierarchicalProfiler::Sample::GroupSamplesInto( Sample& obReceivingSample ) const
{
	if ( CallCount() != 0 )
	{
		Sample& obGroupedSample = obReceivingSample.Child( m_pLabel );
		obGroupedSample.IncreaseCallCount( CallCount() );
		obGroupedSample.IncreaseTime( AccumulatedTime() );
	}

    for ( ChildList::const_iterator obChildIter = m_obChildren.begin(); obChildIter != m_obChildren.end(); ++obChildIter )
		obChildIter->GroupSamplesInto( obReceivingSample );
}


//--------------------------------------------------
//
//! Converts from high-precision clock cycles to seconds.
//! 
//! \param uiTicks	Ticks to convert to seconds.
//! \return			The number of seconds.
//
//--------------------------------------------------
float HierarchicalProfiler::Sample::AsSeconds( int64_t uiTicks )
{
	return static_cast< float >( uiTicks ) * CTimer::GetHWTimerPeriod();
}


//--------------------------------------------------
//
//! Converts from seconds to high-precision clock cycles.
//! 
//! \param fSeconds		Seconds to convert to ticks.
//! \return				The number of ticks.
//
//--------------------------------------------------
int64_t HierarchicalProfiler::Sample::AsTicks( float fSeconds )
{
	return static_cast< int64_t >( fSeconds / CTimer::GetHWTimerPeriod() + 0.5f );
}


//--------------------------------------------------
//
//! Constructs a new hierarchical profiling context. When constructed, changes the current profiling context to this object, so any other
//! hierarchical profiling contexts that are created during the course of its lifetime will be considered "below" this profiling context.
//! When its destructor is called, the time difference is accumulated, and the current context moves to its parent.
//! 
//! \param pSampleLabel		The label of the Sample. We assume this will be generated by the LOAD_PROFILE() macro, so we can simply compare pointers.
//!							This works because by default, string constants are collected into a single location by the compiler - even if the same
//!							constant is repeated in several places in the code, both pointers will refer to the same memory.
//
//--------------------------------------------------
HierarchicalProfiler::HierarchicalProfiler( const char* pSampleLabel )
	: m_pobSample( NULL )
{
	if ( !s_bEnabled )
		return;

	if ( !s_pobSampleTree )
		AllocateSampleTree();

	Sample* pExistingSampleOnStack = s_pobCurrentContext->FindSampleAbove( pSampleLabel );
	if ( pExistingSampleOnStack )
	{
		pExistingSampleOnStack->IncreaseCallCount();
	}
	else
	{
		m_pobSample = &s_pobCurrentContext->Child( pSampleLabel );
		m_pobSample->Start();
		s_pobCurrentContext = m_pobSample;
	}
}


//--------------------------------------------------
//
//! Destructor. Simply calls Stop() on this hierarchical profiling context.
//
//--------------------------------------------------
HierarchicalProfiler::~HierarchicalProfiler()
{
	Stop();
}


//--------------------------------------------------
//
//! Stops the Sample associated with this hierarchical profiling context and sets the current profiling context to this context's parent.
//
//--------------------------------------------------
void HierarchicalProfiler::Stop()
{
	if ( m_pobSample && m_pobSample->IsRunning() )
	{
		m_pobSample->Stop();
		s_pobCurrentContext = m_pobSample->Parent();
	}
}


//--------------------------------------------------
//
//! Allocates the static Root Sample that all the child Samples get appended to.
//
//--------------------------------------------------
void HierarchicalProfiler::AllocateSampleTree()
{
	s_pobSampleTree = NT_NEW Sample( "Root", NULL );
	s_pobCurrentContext = s_pobSampleTree;
}


//--------------------------------------------------
//
//! Deallocates the static Root Sample that all the child Samples get appended to.
//
//--------------------------------------------------
void HierarchicalProfiler::FreeSampleTree()
{
	if ( s_pobSampleTree )
	{
		NT_DELETE( s_pobSampleTree );
		s_pobSampleTree = NULL;
		s_pobCurrentContext = NULL;
	}
}


//--------------------------------------------------
//
//! Outputs a string to both the console and any open log file.
//! 
//! \param pString		Pointer to the string to output.
//
//--------------------------------------------------
void HierarchicalProfiler::OutputString( const char* pString )
{
	Debug::AlwaysOutputString( pString );

#ifndef _HIERARCHICAL_PROFILER_TESTING
	if ( s_pobLogFile && s_pobLogFile->IsValid() )
		s_pobLogFile->Write( pString, strlen( pString ) );
#endif
}


//--------------------------------------------------
//
//! Outputs the collected profiling data to the console and a log file.
//! After this point, all further sampling is disabled, and the memory used by the Samples is freed.
//
//--------------------------------------------------
void HierarchicalProfiler::OutputResults()
{
	// Disable any further sampling.
	s_bEnabled = false;

	// If we don't have any Samples, don't bother to output anything.
	if ( !s_pobSampleTree )
		return;

#ifndef _HIERARCHICAL_PROFILER_TESTING
	if ( !s_pobLogFile )
	{
		Util::SetToPlatformResources();
		s_pobLogFile = Debug::CreateNewLogFile( "load_profiler.log" );
		Util::SetToNeutralResources();
	}
#endif

	Debug::AlwaysOutputString( "\n" );
	OutputString( "Total execution times (significant samples):\n" );
	OutputGroupedSamples();
	
	OutputString( "\nHierarchical breakdown (significant samples):\n" );
	s_pobSampleTree->OutputTree( s_pobSampleTree->WidestLabelColumnWidth( true ) );
	Debug::AlwaysOutputString( "\n" );

#ifndef _HIERARCHICAL_PROFILER_TESTING
	if ( s_pobLogFile )
	{
		if ( s_pobLogFile->IsValid() )
			s_pobLogFile->Flush();

		NT_DELETE( s_pobLogFile );
		s_pobLogFile = NULL;
	}
#endif

	// Deallocate the memory used by the Samples.
	FreeSampleTree();
}


//--------------------------------------------------
//
//! Outputs a sorted list of Samples grouped by their label to the console and a log file.
//
//--------------------------------------------------
void HierarchicalProfiler::OutputGroupedSamples()
{
	if ( !s_pobSampleTree )
		return;

	Sample obGroup( "Group", NULL );
	s_pobSampleTree->GroupSamplesInto( obGroup );
	uint32_t uiWidestLabelColumnWidth = obGroup.WidestLabelColumnWidth();

	SampleList obSortedChildren = obGroup.SortedChildren();
	for ( SampleList::const_iterator obSampleIter = obSortedChildren.begin(); obSampleIter != obSortedChildren.end(); ++obSampleIter )
        ( *obSampleIter )->Output( uiWidestLabelColumnWidth );
}

#endif // _PROFILING
